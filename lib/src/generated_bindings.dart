// ignore_for_file: unused_element, unused_field
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

/// Bindings to LMDB
class LMDBBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LMDBBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LMDBBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// @brief Return the LMDB library version information.
  ///
  /// @param[out] major if non-NULL, the library major version number is copied here
  /// @param[out] minor if non-NULL, the library minor version number is copied here
  /// @param[out] patch if non-NULL, the library patch version number is copied here
  /// @retval "version string" The library version as a string
  ffi.Pointer<ffi.Char> mdb_version(
    ffi.Pointer<ffi.Int> major,
    ffi.Pointer<ffi.Int> minor,
    ffi.Pointer<ffi.Int> patch,
  ) {
    return _mdb_version(major, minor, patch);
  }

  late final _mdb_versionPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
            ffi.Pointer<ffi.Int>,
          )
        >
      >('mdb_version');
  late final _mdb_version = _mdb_versionPtr
      .asFunction<
        ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
        )
      >();

  /// @brief Return a string describing a given error code.
  ///
  /// This function is a superset of the ANSI C X3.159-1989 (ANSI C) strerror(3)
  /// function. If the error code is greater than or equal to 0, then the string
  /// returned by the system function strerror(3) is returned. If the error code
  /// is less than 0, an error string corresponding to the LMDB library error is
  /// returned. See @ref errors for a list of LMDB-specific error codes.
  /// @param[in] err The error code
  /// @retval "error message" The description of the error
  ffi.Pointer<ffi.Char> mdb_strerror(int err) {
    return _mdb_strerror(err);
  }

  late final _mdb_strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
        'mdb_strerror',
      );
  late final _mdb_strerror = _mdb_strerrorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @brief Create an LMDB environment handle.
  ///
  /// This function allocates memory for a #MDB_env structure. To release
  /// the allocated memory and discard the handle, call #mdb_env_close().
  /// Before the handle may be used, it must be opened using #mdb_env_open().
  /// Various other options may also need to be set before opening the handle,
  /// e.g. #mdb_env_set_mapsize(), #mdb_env_set_maxreaders(), #mdb_env_set_maxdbs(),
  /// depending on usage requirements.
  /// @param[out] env The address where the new handle will be stored
  /// @return A non-zero error value on failure and 0 on success.
  int mdb_env_create(ffi.Pointer<ffi.Pointer<MDB_env>> env) {
    return _mdb_env_create(env);
  }

  late final _mdb_env_createPtr =
      _lookup<
        ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Pointer<MDB_env>>)>
      >('mdb_env_create');
  late final _mdb_env_create = _mdb_env_createPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<MDB_env>>)>();

  /// @brief Open an environment handle.
  ///
  /// If this function fails, #mdb_env_close() must be called to discard the #MDB_env handle.
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[in] path The directory in which the database files reside. This
  /// directory must already exist and be writable.
  /// @param[in] flags Special options for this environment. This parameter
  /// must be set to 0 or by bitwise OR'ing together one or more of the
  /// values described here.
  /// Flags set by mdb_env_set_flags() are also used.
  /// <ul>
  /// <li>#MDB_FIXEDMAP
  /// use a fixed address for the mmap region. This flag must be specified
  /// when creating the environment, and is stored persistently in the environment.
  /// If successful, the memory map will always reside at the same virtual address
  /// and pointers used to reference data items in the database will be constant
  /// across multiple invocations. This option may not always work, depending on
  /// how the operating system has allocated memory to shared libraries and other uses.
  /// The feature is highly experimental.
  /// <li>#MDB_NOSUBDIR
  /// By default, LMDB creates its environment in a directory whose
  /// pathname is given in \b path, and creates its data and lock files
  /// under that directory. With this option, \b path is used as-is for
  /// the database main data file. The database lock file is the \b path
  /// with "-lock" appended.
  /// <li>#MDB_RDONLY
  /// Open the environment in read-only mode. No write operations will be
  /// allowed. LMDB will still modify the lock file - except on read-only
  /// filesystems, where LMDB does not use locks.
  /// <li>#MDB_WRITEMAP
  /// Use a writeable memory map unless MDB_RDONLY is set. This uses
  /// fewer mallocs but loses protection from application bugs
  /// like wild pointer writes and other bad updates into the database.
  /// This may be slightly faster for DBs that fit entirely in RAM, but
  /// is slower for DBs larger than RAM.
  /// Incompatible with nested transactions.
  /// Do not mix processes with and without MDB_WRITEMAP on the same
  /// environment.  This can defeat durability (#mdb_env_sync etc).
  /// <li>#MDB_NOMETASYNC
  /// Flush system buffers to disk only once per transaction, omit the
  /// metadata flush. Defer that until the system flushes files to disk,
  /// or next non-MDB_RDONLY commit or #mdb_env_sync(). This optimization
  /// maintains database integrity, but a system crash may undo the last
  /// committed transaction. I.e. it preserves the ACI (atomicity,
  /// consistency, isolation) but not D (durability) database property.
  /// This flag may be changed at any time using #mdb_env_set_flags().
  /// <li>#MDB_NOSYNC
  /// Don't flush system buffers to disk when committing a transaction.
  /// This optimization means a system crash can corrupt the database or
  /// lose the last transactions if buffers are not yet flushed to disk.
  /// The risk is governed by how often the system flushes dirty buffers
  /// to disk and how often #mdb_env_sync() is called.  However, if the
  /// filesystem preserves write order and the #MDB_WRITEMAP flag is not
  /// used, transactions exhibit ACI (atomicity, consistency, isolation)
  /// properties and only lose D (durability).  I.e. database integrity
  /// is maintained, but a system crash may undo the final transactions.
  /// Note that (#MDB_NOSYNC | #MDB_WRITEMAP) leaves the system with no
  /// hint for when to write transactions to disk, unless #mdb_env_sync()
  /// is called. (#MDB_MAPASYNC | #MDB_WRITEMAP) may be preferable.
  /// This flag may be changed at any time using #mdb_env_set_flags().
  /// <li>#MDB_MAPASYNC
  /// When using #MDB_WRITEMAP, use asynchronous flushes to disk.
  /// As with #MDB_NOSYNC, a system crash can then corrupt the
  /// database or lose the last transactions. Calling #mdb_env_sync()
  /// ensures on-disk database integrity until next commit.
  /// This flag may be changed at any time using #mdb_env_set_flags().
  /// <li>#MDB_NOTLS
  /// Don't use Thread-Local Storage. Tie reader locktable slots to
  /// #MDB_txn objects instead of to threads. I.e. #mdb_txn_reset() keeps
  /// the slot reserved for the #MDB_txn object. A thread may use parallel
  /// read-only transactions. A read-only transaction may span threads if
  /// the user synchronizes its use. Applications that multiplex many
  /// user threads over individual OS threads need this option. Such an
  /// application must also serialize the write transactions in an OS
  /// thread, since LMDB's write locking is unaware of the user threads.
  /// <li>#MDB_NOLOCK
  /// Don't do any locking. If concurrent access is anticipated, the
  /// caller must manage all concurrency itself. For proper operation
  /// the caller must enforce single-writer semantics, and must ensure
  /// that no readers are using old transactions while a writer is
  /// active. The simplest approach is to use an exclusive lock so that
  /// no readers may be active at all when a writer begins.
  /// <li>#MDB_NORDAHEAD
  /// Turn off readahead. Most operating systems perform readahead on
  /// read requests by default. This option turns it off if the OS
  /// supports it. Turning it off may help random read performance
  /// when the DB is larger than RAM and system RAM is full.
  /// The option is not implemented on Windows.
  /// <li>#MDB_NOMEMINIT
  /// Don't initialize malloc'd memory before writing to unused spaces
  /// in the data file. By default, memory for pages written to the data
  /// file is obtained using malloc. While these pages may be reused in
  /// subsequent transactions, freshly malloc'd pages will be initialized
  /// to zeroes before use. This avoids persisting leftover data from other
  /// code (that used the heap and subsequently freed the memory) into the
  /// data file. Note that many other system libraries may allocate
  /// and free memory from the heap for arbitrary uses. E.g., stdio may
  /// use the heap for file I/O buffers. This initialization step has a
  /// modest performance cost so some applications may want to disable
  /// it using this flag. This option can be a problem for applications
  /// which handle sensitive data like passwords, and it makes memory
  /// checkers like Valgrind noisy. This flag is not needed with #MDB_WRITEMAP,
  /// which writes directly to the mmap instead of using malloc for pages. The
  /// initialization is also skipped if #MDB_RESERVE is used; the
  /// caller is expected to overwrite all of the memory that was
  /// reserved in that case.
  /// This flag may be changed at any time using #mdb_env_set_flags().
  /// <li>#MDB_PREVSNAPSHOT
  /// Open the environment with the previous snapshot rather than the latest
  /// one. This loses the latest transaction, but may help work around some
  /// types of corruption. If opened with write access, this must be the
  /// only process using the environment. This flag is automatically reset
  /// after a write transaction is successfully committed.
  /// </ul>
  /// @param[in] mode The UNIX permissions to set on created files and semaphores.
  /// This parameter is ignored on Windows.
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>#MDB_VERSION_MISMATCH - the version of the LMDB library doesn't match the
  /// version that created the database environment.
  /// <li>#MDB_INVALID - the environment file headers are corrupted.
  /// <li>ENOENT - the directory specified by the path parameter doesn't exist.
  /// <li>EACCES - the user didn't have permission to access the environment files.
  /// <li>EAGAIN - the environment was locked by another process.
  /// </ul>
  int mdb_env_open(
    ffi.Pointer<MDB_env> env,
    ffi.Pointer<ffi.Char> path,
    int flags,
    int mode,
  ) {
    return _mdb_env_open(env, path, flags, mode);
  }

  late final _mdb_env_openPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_env>,
            ffi.Pointer<ffi.Char>,
            ffi.UnsignedInt,
            mdb_mode_t,
          )
        >
      >('mdb_env_open');
  late final _mdb_env_open = _mdb_env_openPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.Char>, int, int)
      >();

  /// @brief Copy an LMDB environment to the specified path.
  ///
  /// This function may be used to make a backup of an existing environment.
  /// No lockfile is created, since it gets recreated at need.
  /// @note This call can trigger significant file size growth if run in
  /// parallel with write transactions, because it employs a read-only
  /// transaction. See long-lived transactions under @ref caveats_sec.
  /// @param[in] env An environment handle returned by #mdb_env_create(). It
  /// must have already been opened successfully.
  /// @param[in] path The directory in which the copy will reside. This
  /// directory must already exist and be writable but must otherwise be
  /// empty.
  /// @return A non-zero error value on failure and 0 on success.
  int mdb_env_copy(ffi.Pointer<MDB_env> env, ffi.Pointer<ffi.Char> path) {
    return _mdb_env_copy(env, path);
  }

  late final _mdb_env_copyPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.Char>)
        >
      >('mdb_env_copy');
  late final _mdb_env_copy = _mdb_env_copyPtr
      .asFunction<int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.Char>)>();

  /// @brief Copy an LMDB environment to the specified file descriptor.
  ///
  /// This function may be used to make a backup of an existing environment.
  /// No lockfile is created, since it gets recreated at need.
  /// @note This call can trigger significant file size growth if run in
  /// parallel with write transactions, because it employs a read-only
  /// transaction. See long-lived transactions under @ref caveats_sec.
  /// @param[in] env An environment handle returned by #mdb_env_create(). It
  /// must have already been opened successfully.
  /// @param[in] fd The filedescriptor to write the copy to. It must
  /// have already been opened for Write access.
  /// @return A non-zero error value on failure and 0 on success.
  int mdb_env_copyfd(ffi.Pointer<MDB_env> env, int fd) {
    return _mdb_env_copyfd(env, fd);
  }

  late final _mdb_env_copyfdPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, mdb_filehandle_t)
        >
      >('mdb_env_copyfd');
  late final _mdb_env_copyfd = _mdb_env_copyfdPtr
      .asFunction<int Function(ffi.Pointer<MDB_env>, int)>();

  /// @brief Copy an LMDB environment to the specified path, with options.
  ///
  /// This function may be used to make a backup of an existing environment.
  /// No lockfile is created, since it gets recreated at need.
  /// @note This call can trigger significant file size growth if run in
  /// parallel with write transactions, because it employs a read-only
  /// transaction. See long-lived transactions under @ref caveats_sec.
  /// @param[in] env An environment handle returned by #mdb_env_create(). It
  /// must have already been opened successfully.
  /// @param[in] path The directory in which the copy will reside. This
  /// directory must already exist and be writable but must otherwise be
  /// empty.
  /// @param[in] flags Special options for this operation. This parameter
  /// must be set to 0 or by bitwise OR'ing together one or more of the
  /// values described here.
  /// <ul>
  /// <li>#MDB_CP_COMPACT - Perform compaction while copying: omit free
  /// pages and sequentially renumber all pages in output. This option
  /// consumes more CPU and runs more slowly than the default.
  /// Currently it fails if the environment has suffered a page leak.
  /// </ul>
  /// @return A non-zero error value on failure and 0 on success.
  int mdb_env_copy2(
    ffi.Pointer<MDB_env> env,
    ffi.Pointer<ffi.Char> path,
    int flags,
  ) {
    return _mdb_env_copy2(env, path, flags);
  }

  late final _mdb_env_copy2Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_env>,
            ffi.Pointer<ffi.Char>,
            ffi.UnsignedInt,
          )
        >
      >('mdb_env_copy2');
  late final _mdb_env_copy2 = _mdb_env_copy2Ptr
      .asFunction<
        int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.Char>, int)
      >();

  /// @brief Copy an LMDB environment to the specified file descriptor,
  /// with options.
  ///
  /// This function may be used to make a backup of an existing environment.
  /// No lockfile is created, since it gets recreated at need. See
  /// #mdb_env_copy2() for further details.
  /// @note This call can trigger significant file size growth if run in
  /// parallel with write transactions, because it employs a read-only
  /// transaction. See long-lived transactions under @ref caveats_sec.
  /// @param[in] env An environment handle returned by #mdb_env_create(). It
  /// must have already been opened successfully.
  /// @param[in] fd The filedescriptor to write the copy to. It must
  /// have already been opened for Write access.
  /// @param[in] flags Special options for this operation.
  /// See #mdb_env_copy2() for options.
  /// @return A non-zero error value on failure and 0 on success.
  int mdb_env_copyfd2(ffi.Pointer<MDB_env> env, int fd, int flags) {
    return _mdb_env_copyfd2(env, fd, flags);
  }

  late final _mdb_env_copyfd2Ptr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_env>,
            mdb_filehandle_t,
            ffi.UnsignedInt,
          )
        >
      >('mdb_env_copyfd2');
  late final _mdb_env_copyfd2 = _mdb_env_copyfd2Ptr
      .asFunction<int Function(ffi.Pointer<MDB_env>, int, int)>();

  /// @brief Return statistics about the LMDB environment.
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[out] stat The address of an #MDB_stat structure
  /// where the statistics will be copied
  int mdb_env_stat(ffi.Pointer<MDB_env> env, ffi.Pointer<MDB_stat> stat) {
    return _mdb_env_stat(env, stat);
  }

  late final _mdb_env_statPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.Pointer<MDB_stat>)
        >
      >('mdb_env_stat');
  late final _mdb_env_stat = _mdb_env_statPtr
      .asFunction<int Function(ffi.Pointer<MDB_env>, ffi.Pointer<MDB_stat>)>();

  /// @brief Return information about the LMDB environment.
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[out] stat The address of an #MDB_envinfo structure
  /// where the information will be copied
  int mdb_env_info(ffi.Pointer<MDB_env> env, ffi.Pointer<MDB_envinfo> stat) {
    return _mdb_env_info(env, stat);
  }

  late final _mdb_env_infoPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.Pointer<MDB_envinfo>)
        >
      >('mdb_env_info');
  late final _mdb_env_info = _mdb_env_infoPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_env>, ffi.Pointer<MDB_envinfo>)
      >();

  /// @brief Flush the data buffers to disk.
  ///
  /// Data is always written to disk when #mdb_txn_commit() is called,
  /// but the operating system may keep it buffered. LMDB always flushes
  /// the OS buffers upon commit as well, unless the environment was
  /// opened with #MDB_NOSYNC or in part #MDB_NOMETASYNC. This call is
  /// not valid if the environment was opened with #MDB_RDONLY.
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[in] force If non-zero, force a synchronous flush.  Otherwise
  /// if the environment has the #MDB_NOSYNC flag set the flushes
  /// will be omitted, and with #MDB_MAPASYNC they will be asynchronous.
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EACCES - the environment is read-only.
  /// <li>EINVAL - an invalid parameter was specified.
  /// <li>EIO - an error occurred during synchronization.
  /// </ul>
  int mdb_env_sync(ffi.Pointer<MDB_env> env, int force) {
    return _mdb_env_sync(env, force);
  }

  late final _mdb_env_syncPtr =
      _lookup<
        ffi.NativeFunction<ffi.Int Function(ffi.Pointer<MDB_env>, ffi.Int)>
      >('mdb_env_sync');
  late final _mdb_env_sync = _mdb_env_syncPtr
      .asFunction<int Function(ffi.Pointer<MDB_env>, int)>();

  /// @brief Close the environment and release the memory map.
  ///
  /// Only a single thread may call this function. All transactions, databases,
  /// and cursors must already be closed before calling this function. Attempts to
  /// use any such handles after calling this function will cause a SIGSEGV.
  /// The environment handle will be freed and must not be used again after this call.
  /// @param[in] env An environment handle returned by #mdb_env_create()
  void mdb_env_close(ffi.Pointer<MDB_env> env) {
    return _mdb_env_close(env);
  }

  late final _mdb_env_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MDB_env>)>>(
        'mdb_env_close',
      );
  late final _mdb_env_close = _mdb_env_closePtr
      .asFunction<void Function(ffi.Pointer<MDB_env>)>();

  /// @brief Set environment flags.
  ///
  /// This may be used to set some flags in addition to those from
  /// #mdb_env_open(), or to unset these flags.  If several threads
  /// change the flags at the same time, the result is undefined.
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[in] flags The flags to change, bitwise OR'ed together
  /// @param[in] onoff A non-zero value sets the flags, zero clears them.
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_env_set_flags(ffi.Pointer<MDB_env> env, int flags, int onoff) {
    return _mdb_env_set_flags(env, flags, onoff);
  }

  late final _mdb_env_set_flagsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.UnsignedInt, ffi.Int)
        >
      >('mdb_env_set_flags');
  late final _mdb_env_set_flags = _mdb_env_set_flagsPtr
      .asFunction<int Function(ffi.Pointer<MDB_env>, int, int)>();

  /// @brief Get environment flags.
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[out] flags The address of an integer to store the flags
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_env_get_flags(
    ffi.Pointer<MDB_env> env,
    ffi.Pointer<ffi.UnsignedInt> flags,
  ) {
    return _mdb_env_get_flags(env, flags);
  }

  late final _mdb_env_get_flagsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.UnsignedInt>)
        >
      >('mdb_env_get_flags');
  late final _mdb_env_get_flags = _mdb_env_get_flagsPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.UnsignedInt>)
      >();

  /// @brief Return the path that was used in #mdb_env_open().
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[out] path Address of a string pointer to contain the path. This
  /// is the actual string in the environment, not a copy. It should not be
  /// altered in any way.
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_env_get_path(
    ffi.Pointer<MDB_env> env,
    ffi.Pointer<ffi.Pointer<ffi.Char>> path,
  ) {
    return _mdb_env_get_path(env, path);
  }

  late final _mdb_env_get_pathPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_env>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>,
          )
        >
      >('mdb_env_get_path');
  late final _mdb_env_get_path = _mdb_env_get_pathPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.Pointer<ffi.Char>>)
      >();

  /// @brief Return the filedescriptor for the given environment.
  ///
  /// This function may be called after fork(), so the descriptor can be
  /// closed before exec*().  Other LMDB file descriptors have FD_CLOEXEC.
  /// (Until LMDB 0.9.18, only the lockfile had that.)
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[out] fd Address of a mdb_filehandle_t to contain the descriptor.
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_env_get_fd(
    ffi.Pointer<MDB_env> env,
    ffi.Pointer<mdb_filehandle_t> fd,
  ) {
    return _mdb_env_get_fd(env, fd);
  }

  late final _mdb_env_get_fdPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.Pointer<mdb_filehandle_t>)
        >
      >('mdb_env_get_fd');
  late final _mdb_env_get_fd = _mdb_env_get_fdPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_env>, ffi.Pointer<mdb_filehandle_t>)
      >();

  /// @brief Set the size of the memory map to use for this environment.
  ///
  /// The size should be a multiple of the OS page size. The default is
  /// 10485760 bytes. The size of the memory map is also the maximum size
  /// of the database. The value should be chosen as large as possible,
  /// to accommodate future growth of the database.
  /// This function should be called after #mdb_env_create() and before #mdb_env_open().
  /// It may be called at later times if no transactions are active in
  /// this process. Note that the library does not check for this condition,
  /// the caller must ensure it explicitly.
  ///
  /// The new size takes effect immediately for the current process but
  /// will not be persisted to any others until a write transaction has been
  /// committed by the current process. Also, only mapsize increases are
  /// persisted into the environment.
  ///
  /// If the mapsize is increased by another process, and data has grown
  /// beyond the range of the current mapsize, #mdb_txn_begin() will
  /// return #MDB_MAP_RESIZED. This function may be called with a size
  /// of zero to adopt the new size.
  ///
  /// Any attempt to set a size smaller than the space already consumed
  /// by the environment will be silently changed to the current size of the used space.
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[in] size The size in bytes
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified, or the environment has
  /// an active write transaction.
  /// </ul>
  int mdb_env_set_mapsize(ffi.Pointer<MDB_env> env, int size) {
    return _mdb_env_set_mapsize(env, size);
  }

  late final _mdb_env_set_mapsizePtr =
      _lookup<
        ffi.NativeFunction<ffi.Int Function(ffi.Pointer<MDB_env>, mdb_size_t)>
      >('mdb_env_set_mapsize');
  late final _mdb_env_set_mapsize = _mdb_env_set_mapsizePtr
      .asFunction<int Function(ffi.Pointer<MDB_env>, int)>();

  /// @brief Set the maximum number of threads/reader slots for the environment.
  ///
  /// This defines the number of slots in the lock table that is used to track readers in the
  /// the environment. The default is 126.
  /// Starting a read-only transaction normally ties a lock table slot to the
  /// current thread until the environment closes or the thread exits. If
  /// MDB_NOTLS is in use, #mdb_txn_begin() instead ties the slot to the
  /// MDB_txn object until it or the #MDB_env object is destroyed.
  /// This function may only be called after #mdb_env_create() and before #mdb_env_open().
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[in] readers The maximum number of reader lock table slots
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified, or the environment is already open.
  /// </ul>
  int mdb_env_set_maxreaders(ffi.Pointer<MDB_env> env, int readers) {
    return _mdb_env_set_maxreaders(env, readers);
  }

  late final _mdb_env_set_maxreadersPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.UnsignedInt)
        >
      >('mdb_env_set_maxreaders');
  late final _mdb_env_set_maxreaders = _mdb_env_set_maxreadersPtr
      .asFunction<int Function(ffi.Pointer<MDB_env>, int)>();

  /// @brief Get the maximum number of threads/reader slots for the environment.
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[out] readers Address of an integer to store the number of readers
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_env_get_maxreaders(
    ffi.Pointer<MDB_env> env,
    ffi.Pointer<ffi.UnsignedInt> readers,
  ) {
    return _mdb_env_get_maxreaders(env, readers);
  }

  late final _mdb_env_get_maxreadersPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.UnsignedInt>)
        >
      >('mdb_env_get_maxreaders');
  late final _mdb_env_get_maxreaders = _mdb_env_get_maxreadersPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.UnsignedInt>)
      >();

  /// @brief Set the maximum number of named databases for the environment.
  ///
  /// This function is only needed if multiple databases will be used in the
  /// environment. Simpler applications that use the environment as a single
  /// unnamed database can ignore this option.
  /// This function may only be called after #mdb_env_create() and before #mdb_env_open().
  ///
  /// Currently a moderate number of slots are cheap but a huge number gets
  /// expensive: 7-120 words per transaction, and every #mdb_dbi_open()
  /// does a linear search of the opened slots.
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[in] dbs The maximum number of databases
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified, or the environment is already open.
  /// </ul>
  int mdb_env_set_maxdbs(ffi.Pointer<MDB_env> env, int dbs) {
    return _mdb_env_set_maxdbs(env, dbs);
  }

  late final _mdb_env_set_maxdbsPtr =
      _lookup<
        ffi.NativeFunction<ffi.Int Function(ffi.Pointer<MDB_env>, MDB_dbi)>
      >('mdb_env_set_maxdbs');
  late final _mdb_env_set_maxdbs = _mdb_env_set_maxdbsPtr
      .asFunction<int Function(ffi.Pointer<MDB_env>, int)>();

  /// @brief Get the maximum size of keys and #MDB_DUPSORT data we can write.
  ///
  /// Depends on the compile-time constant #MDB_MAXKEYSIZE. Default 511.
  /// See @ref MDB_val.
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @return The maximum size of a key we can write
  int mdb_env_get_maxkeysize(ffi.Pointer<MDB_env> env) {
    return _mdb_env_get_maxkeysize(env);
  }

  late final _mdb_env_get_maxkeysizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<MDB_env>)>>(
        'mdb_env_get_maxkeysize',
      );
  late final _mdb_env_get_maxkeysize = _mdb_env_get_maxkeysizePtr
      .asFunction<int Function(ffi.Pointer<MDB_env>)>();

  /// @brief Set application information associated with the #MDB_env.
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[in] ctx An arbitrary pointer for whatever the application needs.
  /// @return A non-zero error value on failure and 0 on success.
  int mdb_env_set_userctx(ffi.Pointer<MDB_env> env, ffi.Pointer<ffi.Void> ctx) {
    return _mdb_env_set_userctx(env, ctx);
  }

  late final _mdb_env_set_userctxPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.Void>)
        >
      >('mdb_env_set_userctx');
  late final _mdb_env_set_userctx = _mdb_env_set_userctxPtr
      .asFunction<int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.Void>)>();

  /// @brief Get the application information associated with the #MDB_env.
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @return The pointer set by #mdb_env_set_userctx().
  ffi.Pointer<ffi.Void> mdb_env_get_userctx(ffi.Pointer<MDB_env> env) {
    return _mdb_env_get_userctx(env);
  }

  late final _mdb_env_get_userctxPtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<MDB_env>)>
      >('mdb_env_get_userctx');
  late final _mdb_env_get_userctx = _mdb_env_get_userctxPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<MDB_env>)>();

  /// Set or reset the assert() callback of the environment.
  /// Disabled if liblmdb is built with NDEBUG.
  /// @note This hack should become obsolete as lmdb's error handling matures.
  /// @param[in] env An environment handle returned by #mdb_env_create().
  /// @param[in] func An #MDB_assert_func function, or 0.
  /// @return A non-zero error value on failure and 0 on success.
  int mdb_env_set_assert(
    ffi.Pointer<MDB_env> env,
    ffi.Pointer<MDB_assert_func> func,
  ) {
    return _mdb_env_set_assert(env, func);
  }

  late final _mdb_env_set_assertPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.Pointer<MDB_assert_func>)
        >
      >('mdb_env_set_assert');
  late final _mdb_env_set_assert = _mdb_env_set_assertPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_env>, ffi.Pointer<MDB_assert_func>)
      >();

  /// @brief Create a transaction for use with the environment.
  ///
  /// The transaction handle may be discarded using #mdb_txn_abort() or #mdb_txn_commit().
  /// @note A transaction and its cursors must only be used by a single
  /// thread, and a thread may only have a single transaction at a time.
  /// If #MDB_NOTLS is in use, this does not apply to read-only transactions.
  /// @note Cursors may not span transactions.
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[in] parent If this parameter is non-NULL, the new transaction
  /// will be a nested transaction, with the transaction indicated by \b parent
  /// as its parent. Transactions may be nested to any level. A parent
  /// transaction and its cursors may not issue any other operations than
  /// mdb_txn_commit and mdb_txn_abort while it has active child transactions.
  /// @param[in] flags Special options for this transaction. This parameter
  /// must be set to 0 or by bitwise OR'ing together one or more of the
  /// values described here.
  /// <ul>
  /// <li>#MDB_RDONLY
  /// This transaction will not perform any write operations.
  /// <li>#MDB_NOSYNC
  /// Don't flush system buffers to disk when committing this transaction.
  /// <li>#MDB_NOMETASYNC
  /// Flush system buffers but omit metadata flush when committing this transaction.
  /// </ul>
  /// @param[out] txn Address where the new #MDB_txn handle will be stored
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>#MDB_PANIC - a fatal error occurred earlier and the environment
  /// must be shut down.
  /// <li>#MDB_MAP_RESIZED - another process wrote data beyond this MDB_env's
  /// mapsize and this environment's map must be resized as well.
  /// See #mdb_env_set_mapsize().
  /// <li>#MDB_READERS_FULL - a read-only transaction was requested and
  /// the reader lock table is full. See #mdb_env_set_maxreaders().
  /// <li>ENOMEM - out of memory.
  /// </ul>
  int mdb_txn_begin(
    ffi.Pointer<MDB_env> env,
    ffi.Pointer<MDB_txn> parent,
    int flags,
    ffi.Pointer<ffi.Pointer<MDB_txn>> txn,
  ) {
    return _mdb_txn_begin(env, parent, flags, txn);
  }

  late final _mdb_txn_beginPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_env>,
            ffi.Pointer<MDB_txn>,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.Pointer<MDB_txn>>,
          )
        >
      >('mdb_txn_begin');
  late final _mdb_txn_begin = _mdb_txn_beginPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_env>,
          ffi.Pointer<MDB_txn>,
          int,
          ffi.Pointer<ffi.Pointer<MDB_txn>>,
        )
      >();

  /// @brief Returns the transaction's #MDB_env
  ///
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  ffi.Pointer<MDB_env> mdb_txn_env(ffi.Pointer<MDB_txn> txn) {
    return _mdb_txn_env(txn);
  }

  late final _mdb_txn_envPtr =
      _lookup<
        ffi.NativeFunction<ffi.Pointer<MDB_env> Function(ffi.Pointer<MDB_txn>)>
      >('mdb_txn_env');
  late final _mdb_txn_env = _mdb_txn_envPtr
      .asFunction<ffi.Pointer<MDB_env> Function(ffi.Pointer<MDB_txn>)>();

  /// @brief Return the transaction's ID.
  ///
  /// This returns the identifier associated with this transaction. For a
  /// read-only transaction, this corresponds to the snapshot being read;
  /// concurrent readers will frequently have the same transaction ID.
  ///
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @return A transaction ID, valid if input is an active transaction.
  int mdb_txn_id(ffi.Pointer<MDB_txn> txn) {
    return _mdb_txn_id(txn);
  }

  late final _mdb_txn_idPtr =
      _lookup<ffi.NativeFunction<mdb_size_t Function(ffi.Pointer<MDB_txn>)>>(
        'mdb_txn_id',
      );
  late final _mdb_txn_id = _mdb_txn_idPtr
      .asFunction<int Function(ffi.Pointer<MDB_txn>)>();

  /// @brief Commit all the operations of a transaction into the database.
  ///
  /// The transaction handle is freed. It and its cursors must not be used
  /// again after this call, except with #mdb_cursor_renew().
  /// @note Earlier documentation incorrectly said all cursors would be freed.
  /// Only write-transactions free cursors.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// <li>ENOSPC - no more disk space.
  /// <li>EIO - a low-level I/O error occurred while writing.
  /// <li>ENOMEM - out of memory.
  /// </ul>
  int mdb_txn_commit(ffi.Pointer<MDB_txn> txn) {
    return _mdb_txn_commit(txn);
  }

  late final _mdb_txn_commitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<MDB_txn>)>>(
        'mdb_txn_commit',
      );
  late final _mdb_txn_commit = _mdb_txn_commitPtr
      .asFunction<int Function(ffi.Pointer<MDB_txn>)>();

  /// @brief Abandon all the operations of the transaction instead of saving them.
  ///
  /// The transaction handle is freed. It and its cursors must not be used
  /// again after this call, except with #mdb_cursor_renew().
  /// @note Earlier documentation incorrectly said all cursors would be freed.
  /// Only write-transactions free cursors.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  void mdb_txn_abort(ffi.Pointer<MDB_txn> txn) {
    return _mdb_txn_abort(txn);
  }

  late final _mdb_txn_abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MDB_txn>)>>(
        'mdb_txn_abort',
      );
  late final _mdb_txn_abort = _mdb_txn_abortPtr
      .asFunction<void Function(ffi.Pointer<MDB_txn>)>();

  /// @brief Reset a read-only transaction.
  ///
  /// Abort the transaction like #mdb_txn_abort(), but keep the transaction
  /// handle. #mdb_txn_renew() may reuse the handle. This saves allocation
  /// overhead if the process will start a new read-only transaction soon,
  /// and also locking overhead if #MDB_NOTLS is in use. The reader table
  /// lock is released, but the table slot stays tied to its thread or
  /// #MDB_txn. Use mdb_txn_abort() to discard a reset handle, and to free
  /// its lock table slot if MDB_NOTLS is in use.
  /// Cursors opened within the transaction must not be used
  /// again after this call, except with #mdb_cursor_renew().
  /// Reader locks generally don't interfere with writers, but they keep old
  /// versions of database pages allocated. Thus they prevent the old pages
  /// from being reused when writers commit new data, and so under heavy load
  /// the database size may grow much more rapidly than otherwise.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  void mdb_txn_reset(ffi.Pointer<MDB_txn> txn) {
    return _mdb_txn_reset(txn);
  }

  late final _mdb_txn_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MDB_txn>)>>(
        'mdb_txn_reset',
      );
  late final _mdb_txn_reset = _mdb_txn_resetPtr
      .asFunction<void Function(ffi.Pointer<MDB_txn>)>();

  /// @brief Renew a read-only transaction.
  ///
  /// This acquires a new reader lock for a transaction handle that had been
  /// released by #mdb_txn_reset(). It must be called before a reset transaction
  /// may be used again.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>#MDB_PANIC - a fatal error occurred earlier and the environment
  /// must be shut down.
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_txn_renew(ffi.Pointer<MDB_txn> txn) {
    return _mdb_txn_renew(txn);
  }

  late final _mdb_txn_renewPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<MDB_txn>)>>(
        'mdb_txn_renew',
      );
  late final _mdb_txn_renew = _mdb_txn_renewPtr
      .asFunction<int Function(ffi.Pointer<MDB_txn>)>();

  /// @brief Open a database in the environment.
  ///
  /// A database handle denotes the name and parameters of a database,
  /// independently of whether such a database exists.
  /// The database handle may be discarded by calling #mdb_dbi_close().
  /// The old database handle is returned if the database was already open.
  /// The handle may only be closed once.
  ///
  /// The database handle will be private to the current transaction until
  /// the transaction is successfully committed. If the transaction is
  /// aborted the handle will be closed automatically.
  /// After a successful commit the handle will reside in the shared
  /// environment, and may be used by other transactions.
  ///
  /// This function must not be called from multiple concurrent
  /// transactions in the same process. A transaction that uses
  /// this function must finish (either commit or abort) before
  /// any other transaction in the process may use this function.
  ///
  /// To use named databases (with name != NULL), #mdb_env_set_maxdbs()
  /// must be called before opening the environment.  Database names are
  /// keys in the unnamed database, and may be read but not written.
  ///
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] name The name of the database to open. If only a single
  /// database is needed in the environment, this value may be NULL.
  /// @param[in] flags Special options for this database. This parameter
  /// must be set to 0 or by bitwise OR'ing together one or more of the
  /// values described here.
  /// <ul>
  /// <li>#MDB_REVERSEKEY
  /// Keys are strings to be compared in reverse order, from the end
  /// of the strings to the beginning. By default, Keys are treated as strings and
  /// compared from beginning to end.
  /// <li>#MDB_DUPSORT
  /// Duplicate keys may be used in the database. (Or, from another perspective,
  /// keys may have multiple data items, stored in sorted order.) By default
  /// keys must be unique and may have only a single data item.
  /// <li>#MDB_INTEGERKEY
  /// Keys are binary integers in native byte order, either unsigned int
  /// or #mdb_size_t, and will be sorted as such.
  /// (lmdb expects 32-bit int <= size_t <= 32/64-bit mdb_size_t.)
  /// The keys must all be of the same size.
  /// <li>#MDB_DUPFIXED
  /// This flag may only be used in combination with #MDB_DUPSORT. This option
  /// tells the library that the data items for this database are all the same
  /// size, which allows further optimizations in storage and retrieval. When
  /// all data items are the same size, the #MDB_GET_MULTIPLE, #MDB_NEXT_MULTIPLE
  /// and #MDB_PREV_MULTIPLE cursor operations may be used to retrieve multiple
  /// items at once.
  /// <li>#MDB_INTEGERDUP
  /// This option specifies that duplicate data items are binary integers,
  /// similar to #MDB_INTEGERKEY keys.
  /// <li>#MDB_REVERSEDUP
  /// This option specifies that duplicate data items should be compared as
  /// strings in reverse order.
  /// <li>#MDB_CREATE
  /// Create the named database if it doesn't exist. This option is not
  /// allowed in a read-only transaction or a read-only environment.
  /// </ul>
  /// @param[out] dbi Address where the new #MDB_dbi handle will be stored
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>#MDB_NOTFOUND - the specified database doesn't exist in the environment
  /// and #MDB_CREATE was not specified.
  /// <li>#MDB_DBS_FULL - too many databases have been opened. See #mdb_env_set_maxdbs().
  /// </ul>
  int mdb_dbi_open(
    ffi.Pointer<MDB_txn> txn,
    ffi.Pointer<ffi.Char> name,
    int flags,
    ffi.Pointer<MDB_dbi> dbi,
  ) {
    return _mdb_dbi_open(txn, name, flags, dbi);
  }

  late final _mdb_dbi_openPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            ffi.Pointer<ffi.Char>,
            ffi.UnsignedInt,
            ffi.Pointer<MDB_dbi>,
          )
        >
      >('mdb_dbi_open');
  late final _mdb_dbi_open = _mdb_dbi_openPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_txn>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<MDB_dbi>,
        )
      >();

  /// @brief Retrieve statistics for a database.
  ///
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[out] stat The address of an #MDB_stat structure
  /// where the statistics will be copied
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_stat(ffi.Pointer<MDB_txn> txn, int dbi, ffi.Pointer<MDB_stat> stat) {
    return _mdb_stat(txn, dbi, stat);
  }

  late final _mdb_statPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_txn>, MDB_dbi, ffi.Pointer<MDB_stat>)
        >
      >('mdb_stat');
  late final _mdb_stat = _mdb_statPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_txn>, int, ffi.Pointer<MDB_stat>)
      >();

  /// @brief Retrieve the DB flags for a database handle.
  ///
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[out] flags Address where the flags will be returned.
  /// @return A non-zero error value on failure and 0 on success.
  int mdb_dbi_flags(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<ffi.UnsignedInt> flags,
  ) {
    return _mdb_dbi_flags(txn, dbi, flags);
  }

  late final _mdb_dbi_flagsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            MDB_dbi,
            ffi.Pointer<ffi.UnsignedInt>,
          )
        >
      >('mdb_dbi_flags');
  late final _mdb_dbi_flags = _mdb_dbi_flagsPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_txn>, int, ffi.Pointer<ffi.UnsignedInt>)
      >();

  /// @brief Close a database handle. Normally unnecessary. Use with care:
  ///
  /// This call is not mutex protected. Handles should only be closed by
  /// a single thread, and only if no other threads are going to reference
  /// the database handle or one of its cursors any further. Do not close
  /// a handle if an existing transaction has modified its database.
  /// Doing so can cause misbehavior from database corruption to errors
  /// like MDB_BAD_VALSIZE (since the DB name is gone).
  ///
  /// Closing a database handle is not necessary, but lets #mdb_dbi_open()
  /// reuse the handle value.  Usually it's better to set a bigger
  /// #mdb_env_set_maxdbs(), unless that value would be large.
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  void mdb_dbi_close(ffi.Pointer<MDB_env> env, int dbi) {
    return _mdb_dbi_close(env, dbi);
  }

  late final _mdb_dbi_closePtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MDB_env>, MDB_dbi)>
      >('mdb_dbi_close');
  late final _mdb_dbi_close = _mdb_dbi_closePtr
      .asFunction<void Function(ffi.Pointer<MDB_env>, int)>();

  /// @brief Empty or delete+close a database.
  ///
  /// See #mdb_dbi_close() for restrictions about closing the DB handle.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[in] del 0 to empty the DB, 1 to delete it from the
  /// environment and close the DB handle.
  /// @return A non-zero error value on failure and 0 on success.
  int mdb_drop(ffi.Pointer<MDB_txn> txn, int dbi, int del) {
    return _mdb_drop(txn, dbi, del);
  }

  late final _mdb_dropPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_txn>, MDB_dbi, ffi.Int)
        >
      >('mdb_drop');
  late final _mdb_drop = _mdb_dropPtr
      .asFunction<int Function(ffi.Pointer<MDB_txn>, int, int)>();

  /// @brief Set a custom key comparison function for a database.
  ///
  /// The comparison function is called whenever it is necessary to compare a
  /// key specified by the application with a key currently stored in the database.
  /// If no comparison function is specified, and no special key flags were specified
  /// with #mdb_dbi_open(), the keys are compared lexically, with shorter keys collating
  /// before longer keys.
  /// @warning This function must be called before any data access functions are used,
  /// otherwise data corruption may occur. The same comparison function must be used by every
  /// program accessing the database, every time the database is used.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[in] cmp A #MDB_cmp_func function
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_set_compare(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<MDB_cmp_func> cmp,
  ) {
    return _mdb_set_compare(txn, dbi, cmp);
  }

  late final _mdb_set_comparePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            MDB_dbi,
            ffi.Pointer<MDB_cmp_func>,
          )
        >
      >('mdb_set_compare');
  late final _mdb_set_compare = _mdb_set_comparePtr
      .asFunction<
        int Function(ffi.Pointer<MDB_txn>, int, ffi.Pointer<MDB_cmp_func>)
      >();

  /// @brief Set a custom data comparison function for a #MDB_DUPSORT database.
  ///
  /// This comparison function is called whenever it is necessary to compare a data
  /// item specified by the application with a data item currently stored in the database.
  /// This function only takes effect if the database was opened with the #MDB_DUPSORT
  /// flag.
  /// If no comparison function is specified, and no special key flags were specified
  /// with #mdb_dbi_open(), the data items are compared lexically, with shorter items collating
  /// before longer items.
  /// @warning This function must be called before any data access functions are used,
  /// otherwise data corruption may occur. The same comparison function must be used by every
  /// program accessing the database, every time the database is used.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[in] cmp A #MDB_cmp_func function
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_set_dupsort(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<MDB_cmp_func> cmp,
  ) {
    return _mdb_set_dupsort(txn, dbi, cmp);
  }

  late final _mdb_set_dupsortPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            MDB_dbi,
            ffi.Pointer<MDB_cmp_func>,
          )
        >
      >('mdb_set_dupsort');
  late final _mdb_set_dupsort = _mdb_set_dupsortPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_txn>, int, ffi.Pointer<MDB_cmp_func>)
      >();

  /// @brief Set a relocation function for a #MDB_FIXEDMAP database.
  ///
  /// @todo The relocation function is called whenever it is necessary to move the data
  /// of an item to a different position in the database (e.g. through tree
  /// balancing operations, shifts as a result of adds or deletes, etc.). It is
  /// intended to allow address/position-dependent data items to be stored in
  /// a database in an environment opened with the #MDB_FIXEDMAP option.
  /// Currently the relocation feature is unimplemented and setting
  /// this function has no effect.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[in] rel A #MDB_rel_func function
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_set_relfunc(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<MDB_rel_func> rel,
  ) {
    return _mdb_set_relfunc(txn, dbi, rel);
  }

  late final _mdb_set_relfuncPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            MDB_dbi,
            ffi.Pointer<MDB_rel_func>,
          )
        >
      >('mdb_set_relfunc');
  late final _mdb_set_relfunc = _mdb_set_relfuncPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_txn>, int, ffi.Pointer<MDB_rel_func>)
      >();

  /// @brief Set a context pointer for a #MDB_FIXEDMAP database's relocation function.
  ///
  /// See #mdb_set_relfunc and #MDB_rel_func for more details.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[in] ctx An arbitrary pointer for whatever the application needs.
  /// It will be passed to the callback function set by #mdb_set_relfunc
  /// as its \b relctx parameter whenever the callback is invoked.
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_set_relctx(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<ffi.Void> ctx,
  ) {
    return _mdb_set_relctx(txn, dbi, ctx);
  }

  late final _mdb_set_relctxPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_txn>, MDB_dbi, ffi.Pointer<ffi.Void>)
        >
      >('mdb_set_relctx');
  late final _mdb_set_relctx = _mdb_set_relctxPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_txn>, int, ffi.Pointer<ffi.Void>)
      >();

  /// @brief Get items from a database.
  ///
  /// This function retrieves key/data pairs from the database. The address
  /// and length of the data associated with the specified \b key are returned
  /// in the structure to which \b data refers.
  /// If the database supports duplicate keys (#MDB_DUPSORT) then the
  /// first data item for the key will be returned. Retrieval of other
  /// items requires the use of #mdb_cursor_get().
  ///
  /// @note The memory pointed to by the returned values is owned by the
  /// database. The caller need not dispose of the memory, and may not
  /// modify it in any way. For values returned in a read-only transaction
  /// any modification attempts will cause a SIGSEGV.
  /// @note Values returned from the database are valid only until a
  /// subsequent update operation, or the end of the transaction.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[in] key The key to search for in the database
  /// @param[out] data The data corresponding to the key
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>#MDB_NOTFOUND - the key was not in the database.
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_get(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<MDB_val> key,
    ffi.Pointer<MDB_val> data,
  ) {
    return _mdb_get(txn, dbi, key, data);
  }

  late final _mdb_getPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            MDB_dbi,
            ffi.Pointer<MDB_val>,
            ffi.Pointer<MDB_val>,
          )
        >
      >('mdb_get');
  late final _mdb_get = _mdb_getPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_txn>,
          int,
          ffi.Pointer<MDB_val>,
          ffi.Pointer<MDB_val>,
        )
      >();

  /// @brief Store items into a database.
  ///
  /// This function stores key/data pairs in the database. The default behavior
  /// is to enter the new key/data pair, replacing any previously existing key
  /// if duplicates are disallowed, or adding a duplicate data item if
  /// duplicates are allowed (#MDB_DUPSORT).
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[in] key The key to store in the database
  /// @param[in,out] data The data to store
  /// @param[in] flags Special options for this operation. This parameter
  /// must be set to 0 or by bitwise OR'ing together one or more of the
  /// values described here.
  /// <ul>
  /// <li>#MDB_NODUPDATA - enter the new key/data pair only if it does not
  /// already appear in the database. This flag may only be specified
  /// if the database was opened with #MDB_DUPSORT. The function will
  /// return #MDB_KEYEXIST if the key/data pair already appears in the
  /// database.
  /// <li>#MDB_NOOVERWRITE - enter the new key/data pair only if the key
  /// does not already appear in the database. The function will return
  /// #MDB_KEYEXIST if the key already appears in the database, even if
  /// the database supports duplicates (#MDB_DUPSORT). The \b data
  /// parameter will be set to point to the existing item.
  /// <li>#MDB_RESERVE - reserve space for data of the given size, but
  /// don't copy the given data. Instead, return a pointer to the
  /// reserved space, which the caller can fill in later - before
  /// the next update operation or the transaction ends. This saves
  /// an extra memcpy if the data is being generated later.
  /// LMDB does nothing else with this memory, the caller is expected
  /// to modify all of the space requested. This flag must not be
  /// specified if the database was opened with #MDB_DUPSORT.
  /// <li>#MDB_APPEND - append the given key/data pair to the end of the
  /// database. This option allows fast bulk loading when keys are
  /// already known to be in the correct order. Loading unsorted keys
  /// with this flag will cause a #MDB_KEYEXIST error.
  /// <li>#MDB_APPENDDUP - as above, but for sorted dup data.
  /// </ul>
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>#MDB_MAP_FULL - the database is full, see #mdb_env_set_mapsize().
  /// <li>#MDB_TXN_FULL - the transaction has too many dirty pages.
  /// <li>EACCES - an attempt was made to write in a read-only transaction.
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_put(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<MDB_val> key,
    ffi.Pointer<MDB_val> data,
    int flags,
  ) {
    return _mdb_put(txn, dbi, key, data, flags);
  }

  late final _mdb_putPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            MDB_dbi,
            ffi.Pointer<MDB_val>,
            ffi.Pointer<MDB_val>,
            ffi.UnsignedInt,
          )
        >
      >('mdb_put');
  late final _mdb_put = _mdb_putPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_txn>,
          int,
          ffi.Pointer<MDB_val>,
          ffi.Pointer<MDB_val>,
          int,
        )
      >();

  /// @brief Delete items from a database.
  ///
  /// This function removes key/data pairs from the database.
  /// If the database does not support sorted duplicate data items
  /// (#MDB_DUPSORT) the data parameter is ignored.
  /// If the database supports sorted duplicates and the data parameter
  /// is NULL, all of the duplicate data items for the key will be
  /// deleted. Otherwise, if the data parameter is non-NULL
  /// only the matching data item will be deleted.
  /// This function will return #MDB_NOTFOUND if the specified key/data
  /// pair is not in the database.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[in] key The key to delete from the database
  /// @param[in] data The data to delete
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EACCES - an attempt was made to write in a read-only transaction.
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_del(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<MDB_val> key,
    ffi.Pointer<MDB_val> data,
  ) {
    return _mdb_del(txn, dbi, key, data);
  }

  late final _mdb_delPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            MDB_dbi,
            ffi.Pointer<MDB_val>,
            ffi.Pointer<MDB_val>,
          )
        >
      >('mdb_del');
  late final _mdb_del = _mdb_delPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_txn>,
          int,
          ffi.Pointer<MDB_val>,
          ffi.Pointer<MDB_val>,
        )
      >();

  /// @brief Create a cursor handle.
  ///
  /// A cursor is associated with a specific transaction and database.
  /// A cursor cannot be used when its database handle is closed.  Nor
  /// when its transaction has ended, except with #mdb_cursor_renew().
  /// It can be discarded with #mdb_cursor_close().
  /// A cursor in a write-transaction can be closed before its transaction
  /// ends, and will otherwise be closed when its transaction ends.
  /// A cursor in a read-only transaction must be closed explicitly, before
  /// or after its transaction ends. It can be reused with
  /// #mdb_cursor_renew() before finally closing it.
  /// @note Earlier documentation said that cursors in every transaction
  /// were closed when the transaction committed or aborted.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[out] cursor Address where the new #MDB_cursor handle will be stored
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_cursor_open(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<ffi.Pointer<MDB_cursor>> cursor,
  ) {
    return _mdb_cursor_open(txn, dbi, cursor);
  }

  late final _mdb_cursor_openPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            MDB_dbi,
            ffi.Pointer<ffi.Pointer<MDB_cursor>>,
          )
        >
      >('mdb_cursor_open');
  late final _mdb_cursor_open = _mdb_cursor_openPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_txn>,
          int,
          ffi.Pointer<ffi.Pointer<MDB_cursor>>,
        )
      >();

  /// @brief Close a cursor handle.
  ///
  /// The cursor handle will be freed and must not be used again after this call.
  /// Its transaction must still be live if it is a write-transaction.
  /// @param[in] cursor A cursor handle returned by #mdb_cursor_open()
  void mdb_cursor_close(ffi.Pointer<MDB_cursor> cursor) {
    return _mdb_cursor_close(cursor);
  }

  late final _mdb_cursor_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<MDB_cursor>)>>(
        'mdb_cursor_close',
      );
  late final _mdb_cursor_close = _mdb_cursor_closePtr
      .asFunction<void Function(ffi.Pointer<MDB_cursor>)>();

  /// @brief Renew a cursor handle.
  ///
  /// A cursor is associated with a specific transaction and database.
  /// Cursors that are only used in read-only
  /// transactions may be re-used, to avoid unnecessary malloc/free overhead.
  /// The cursor may be associated with a new read-only transaction, and
  /// referencing the same database handle as it was created with.
  /// This may be done whether the previous transaction is live or dead.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] cursor A cursor handle returned by #mdb_cursor_open()
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_cursor_renew(
    ffi.Pointer<MDB_txn> txn,
    ffi.Pointer<MDB_cursor> cursor,
  ) {
    return _mdb_cursor_renew(txn, cursor);
  }

  late final _mdb_cursor_renewPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_txn>, ffi.Pointer<MDB_cursor>)
        >
      >('mdb_cursor_renew');
  late final _mdb_cursor_renew = _mdb_cursor_renewPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_txn>, ffi.Pointer<MDB_cursor>)
      >();

  /// @brief Return the cursor's transaction handle.
  ///
  /// @param[in] cursor A cursor handle returned by #mdb_cursor_open()
  ffi.Pointer<MDB_txn> mdb_cursor_txn(ffi.Pointer<MDB_cursor> cursor) {
    return _mdb_cursor_txn(cursor);
  }

  late final _mdb_cursor_txnPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<MDB_txn> Function(ffi.Pointer<MDB_cursor>)
        >
      >('mdb_cursor_txn');
  late final _mdb_cursor_txn = _mdb_cursor_txnPtr
      .asFunction<ffi.Pointer<MDB_txn> Function(ffi.Pointer<MDB_cursor>)>();

  /// @brief Return the cursor's database handle.
  ///
  /// @param[in] cursor A cursor handle returned by #mdb_cursor_open()
  int mdb_cursor_dbi(ffi.Pointer<MDB_cursor> cursor) {
    return _mdb_cursor_dbi(cursor);
  }

  late final _mdb_cursor_dbiPtr =
      _lookup<ffi.NativeFunction<MDB_dbi Function(ffi.Pointer<MDB_cursor>)>>(
        'mdb_cursor_dbi',
      );
  late final _mdb_cursor_dbi = _mdb_cursor_dbiPtr
      .asFunction<int Function(ffi.Pointer<MDB_cursor>)>();

  /// @brief Retrieve by cursor.
  ///
  /// This function retrieves key/data pairs from the database. The address and length
  /// of the key are returned in the object to which \b key refers (except for the
  /// case of the #MDB_SET option, in which the \b key object is unchanged), and
  /// the address and length of the data are returned in the object to which \b data
  /// refers.
  /// See #mdb_get() for restrictions on using the output values.
  /// @param[in] cursor A cursor handle returned by #mdb_cursor_open()
  /// @param[in,out] key The key for a retrieved item
  /// @param[in,out] data The data of a retrieved item
  /// @param[in] op A cursor operation #MDB_cursor_op
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>#MDB_NOTFOUND - no matching key found.
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_cursor_get(
    ffi.Pointer<MDB_cursor> cursor,
    ffi.Pointer<MDB_val> key,
    ffi.Pointer<MDB_val> data,
    MDB_cursor_op op,
  ) {
    return _mdb_cursor_get(cursor, key, data, op.value);
  }

  late final _mdb_cursor_getPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_cursor>,
            ffi.Pointer<MDB_val>,
            ffi.Pointer<MDB_val>,
            ffi.UnsignedInt,
          )
        >
      >('mdb_cursor_get');
  late final _mdb_cursor_get = _mdb_cursor_getPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_cursor>,
          ffi.Pointer<MDB_val>,
          ffi.Pointer<MDB_val>,
          int,
        )
      >();

  /// @brief Store by cursor.
  ///
  /// This function stores key/data pairs into the database.
  /// The cursor is positioned at the new item, or on failure usually near it.
  /// @note Earlier documentation incorrectly said errors would leave the
  /// state of the cursor unchanged.
  /// @param[in] cursor A cursor handle returned by #mdb_cursor_open()
  /// @param[in] key The key operated on.
  /// @param[in] data The data operated on.
  /// @param[in] flags Options for this operation. This parameter
  /// must be set to 0 or one of the values described here.
  /// <ul>
  /// <li>#MDB_CURRENT - replace the item at the current cursor position.
  /// The \b key parameter must still be provided, and must match it.
  /// If using sorted duplicates (#MDB_DUPSORT) the data item must still
  /// sort into the same place. This is intended to be used when the
  /// new data is the same size as the old. Otherwise it will simply
  /// perform a delete of the old record followed by an insert.
  /// <li>#MDB_NODUPDATA - enter the new key/data pair only if it does not
  /// already appear in the database. This flag may only be specified
  /// if the database was opened with #MDB_DUPSORT. The function will
  /// return #MDB_KEYEXIST if the key/data pair already appears in the
  /// database.
  /// <li>#MDB_NOOVERWRITE - enter the new key/data pair only if the key
  /// does not already appear in the database. The function will return
  /// #MDB_KEYEXIST if the key already appears in the database, even if
  /// the database supports duplicates (#MDB_DUPSORT).
  /// <li>#MDB_RESERVE - reserve space for data of the given size, but
  /// don't copy the given data. Instead, return a pointer to the
  /// reserved space, which the caller can fill in later - before
  /// the next update operation or the transaction ends. This saves
  /// an extra memcpy if the data is being generated later. This flag
  /// must not be specified if the database was opened with #MDB_DUPSORT.
  /// <li>#MDB_APPEND - append the given key/data pair to the end of the
  /// database. No key comparisons are performed. This option allows
  /// fast bulk loading when keys are already known to be in the
  /// correct order. Loading unsorted keys with this flag will cause
  /// a #MDB_KEYEXIST error.
  /// <li>#MDB_APPENDDUP - as above, but for sorted dup data.
  /// <li>#MDB_MULTIPLE - store multiple contiguous data elements in a
  /// single request. This flag may only be specified if the database
  /// was opened with #MDB_DUPFIXED. The \b data argument must be an
  /// array of two MDB_vals. The mv_size of the first MDB_val must be
  /// the size of a single data element. The mv_data of the first MDB_val
  /// must point to the beginning of the array of contiguous data elements.
  /// The mv_size of the second MDB_val must be the count of the number
  /// of data elements to store. On return this field will be set to
  /// the count of the number of elements actually written. The mv_data
  /// of the second MDB_val is unused.
  /// </ul>
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>#MDB_MAP_FULL - the database is full, see #mdb_env_set_mapsize().
  /// <li>#MDB_TXN_FULL - the transaction has too many dirty pages.
  /// <li>EACCES - an attempt was made to write in a read-only transaction.
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_cursor_put(
    ffi.Pointer<MDB_cursor> cursor,
    ffi.Pointer<MDB_val> key,
    ffi.Pointer<MDB_val> data,
    int flags,
  ) {
    return _mdb_cursor_put(cursor, key, data, flags);
  }

  late final _mdb_cursor_putPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_cursor>,
            ffi.Pointer<MDB_val>,
            ffi.Pointer<MDB_val>,
            ffi.UnsignedInt,
          )
        >
      >('mdb_cursor_put');
  late final _mdb_cursor_put = _mdb_cursor_putPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_cursor>,
          ffi.Pointer<MDB_val>,
          ffi.Pointer<MDB_val>,
          int,
        )
      >();

  /// @brief Delete current key/data pair
  ///
  /// This function deletes the key/data pair to which the cursor refers.
  /// This does not invalidate the cursor, so operations such as MDB_NEXT
  /// can still be used on it.
  /// Both MDB_NEXT and MDB_GET_CURRENT will return the same record after
  /// this operation.
  /// @param[in] cursor A cursor handle returned by #mdb_cursor_open()
  /// @param[in] flags Options for this operation. This parameter
  /// must be set to 0 or one of the values described here.
  /// <ul>
  /// <li>#MDB_NODUPDATA - delete all of the data items for the current key.
  /// This flag may only be specified if the database was opened with #MDB_DUPSORT.
  /// </ul>
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EACCES - an attempt was made to write in a read-only transaction.
  /// <li>EINVAL - an invalid parameter was specified.
  /// </ul>
  int mdb_cursor_del(ffi.Pointer<MDB_cursor> cursor, int flags) {
    return _mdb_cursor_del(cursor, flags);
  }

  late final _mdb_cursor_delPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_cursor>, ffi.UnsignedInt)
        >
      >('mdb_cursor_del');
  late final _mdb_cursor_del = _mdb_cursor_delPtr
      .asFunction<int Function(ffi.Pointer<MDB_cursor>, int)>();

  /// @brief Return count of duplicates for current key.
  ///
  /// This call is only valid on databases that support sorted duplicate
  /// data items #MDB_DUPSORT.
  /// @param[in] cursor A cursor handle returned by #mdb_cursor_open()
  /// @param[out] countp Address where the count will be stored
  /// @return A non-zero error value on failure and 0 on success. Some possible
  /// errors are:
  /// <ul>
  /// <li>EINVAL - cursor is not initialized, or an invalid parameter was specified.
  /// </ul>
  int mdb_cursor_count(
    ffi.Pointer<MDB_cursor> cursor,
    ffi.Pointer<mdb_size_t> countp,
  ) {
    return _mdb_cursor_count(cursor, countp);
  }

  late final _mdb_cursor_countPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_cursor>, ffi.Pointer<mdb_size_t>)
        >
      >('mdb_cursor_count');
  late final _mdb_cursor_count = _mdb_cursor_countPtr
      .asFunction<
        int Function(ffi.Pointer<MDB_cursor>, ffi.Pointer<mdb_size_t>)
      >();

  /// @brief Compare two data items according to a particular database.
  ///
  /// This returns a comparison as if the two data items were keys in the
  /// specified database.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[in] a The first item to compare
  /// @param[in] b The second item to compare
  /// @return < 0 if a < b, 0 if a == b, > 0 if a > b
  int mdb_cmp(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<MDB_val> a,
    ffi.Pointer<MDB_val> b,
  ) {
    return _mdb_cmp(txn, dbi, a, b);
  }

  late final _mdb_cmpPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            MDB_dbi,
            ffi.Pointer<MDB_val>,
            ffi.Pointer<MDB_val>,
          )
        >
      >('mdb_cmp');
  late final _mdb_cmp = _mdb_cmpPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_txn>,
          int,
          ffi.Pointer<MDB_val>,
          ffi.Pointer<MDB_val>,
        )
      >();

  /// @brief Compare two data items according to a particular database.
  ///
  /// This returns a comparison as if the two items were data items of
  /// the specified database. The database must have the #MDB_DUPSORT flag.
  /// @param[in] txn A transaction handle returned by #mdb_txn_begin()
  /// @param[in] dbi A database handle returned by #mdb_dbi_open()
  /// @param[in] a The first item to compare
  /// @param[in] b The second item to compare
  /// @return < 0 if a < b, 0 if a == b, > 0 if a > b
  int mdb_dcmp(
    ffi.Pointer<MDB_txn> txn,
    int dbi,
    ffi.Pointer<MDB_val> a,
    ffi.Pointer<MDB_val> b,
  ) {
    return _mdb_dcmp(txn, dbi, a, b);
  }

  late final _mdb_dcmpPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_txn>,
            MDB_dbi,
            ffi.Pointer<MDB_val>,
            ffi.Pointer<MDB_val>,
          )
        >
      >('mdb_dcmp');
  late final _mdb_dcmp = _mdb_dcmpPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_txn>,
          int,
          ffi.Pointer<MDB_val>,
          ffi.Pointer<MDB_val>,
        )
      >();

  /// @brief Dump the entries in the reader lock table.
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[in] func A #MDB_msg_func function
  /// @param[in] ctx Anything the message function needs
  /// @return < 0 on failure, >= 0 on success.
  int mdb_reader_list(
    ffi.Pointer<MDB_env> env,
    ffi.Pointer<MDB_msg_func> func,
    ffi.Pointer<ffi.Void> ctx,
  ) {
    return _mdb_reader_list(env, func, ctx);
  }

  late final _mdb_reader_listPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(
            ffi.Pointer<MDB_env>,
            ffi.Pointer<MDB_msg_func>,
            ffi.Pointer<ffi.Void>,
          )
        >
      >('mdb_reader_list');
  late final _mdb_reader_list = _mdb_reader_listPtr
      .asFunction<
        int Function(
          ffi.Pointer<MDB_env>,
          ffi.Pointer<MDB_msg_func>,
          ffi.Pointer<ffi.Void>,
        )
      >();

  /// @brief Check for stale entries in the reader lock table.
  ///
  /// @param[in] env An environment handle returned by #mdb_env_create()
  /// @param[out] dead Number of stale slots that were cleared
  /// @return 0 on success, non-zero on failure.
  int mdb_reader_check(ffi.Pointer<MDB_env> env, ffi.Pointer<ffi.Int> dead) {
    return _mdb_reader_check(env, dead);
  }

  late final _mdb_reader_checkPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.Int>)
        >
      >('mdb_reader_check');
  late final _mdb_reader_check = _mdb_reader_checkPtr
      .asFunction<int Function(ffi.Pointer<MDB_env>, ffi.Pointer<ffi.Int>)>();
}

typedef __u_char = ffi.UnsignedChar;
typedef Dart__u_char = int;
typedef __u_short = ffi.UnsignedShort;
typedef Dart__u_short = int;
typedef __u_int = ffi.UnsignedInt;
typedef Dart__u_int = int;
typedef __u_long = ffi.UnsignedLong;
typedef Dart__u_long = int;
typedef __int8_t = ffi.SignedChar;
typedef Dart__int8_t = int;
typedef __uint8_t = ffi.UnsignedChar;
typedef Dart__uint8_t = int;
typedef __int16_t = ffi.Short;
typedef Dart__int16_t = int;
typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;
typedef __int64_t = ffi.Long;
typedef Dart__int64_t = int;
typedef __uint64_t = ffi.UnsignedLong;
typedef Dart__uint64_t = int;
typedef __int_least8_t = __int8_t;
typedef __uint_least8_t = __uint8_t;
typedef __int_least16_t = __int16_t;
typedef __uint_least16_t = __uint16_t;
typedef __int_least32_t = __int32_t;
typedef __uint_least32_t = __uint32_t;
typedef __int_least64_t = __int64_t;
typedef __uint_least64_t = __uint64_t;
typedef __quad_t = ffi.Long;
typedef Dart__quad_t = int;
typedef __u_quad_t = ffi.UnsignedLong;
typedef Dart__u_quad_t = int;
typedef __intmax_t = ffi.Long;
typedef Dart__intmax_t = int;
typedef __uintmax_t = ffi.UnsignedLong;
typedef Dart__uintmax_t = int;
typedef __dev_t = ffi.UnsignedLong;
typedef Dart__dev_t = int;
typedef __uid_t = ffi.UnsignedInt;
typedef Dart__uid_t = int;
typedef __gid_t = ffi.UnsignedInt;
typedef Dart__gid_t = int;
typedef __ino_t = ffi.UnsignedLong;
typedef Dart__ino_t = int;
typedef __ino64_t = ffi.UnsignedLong;
typedef Dart__ino64_t = int;
typedef __mode_t = ffi.UnsignedInt;
typedef Dart__mode_t = int;
typedef __nlink_t = ffi.UnsignedLong;
typedef Dart__nlink_t = int;
typedef __off_t = ffi.Long;
typedef Dart__off_t = int;
typedef __off64_t = ffi.Long;
typedef Dart__off64_t = int;
typedef __pid_t = ffi.Int;
typedef Dart__pid_t = int;

final class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> __val;
}

typedef __clock_t = ffi.Long;
typedef Dart__clock_t = int;
typedef __rlim_t = ffi.UnsignedLong;
typedef Dart__rlim_t = int;
typedef __rlim64_t = ffi.UnsignedLong;
typedef Dart__rlim64_t = int;
typedef __id_t = ffi.UnsignedInt;
typedef Dart__id_t = int;
typedef __time_t = ffi.Long;
typedef Dart__time_t = int;
typedef __useconds_t = ffi.UnsignedInt;
typedef Dart__useconds_t = int;
typedef __suseconds_t = ffi.Long;
typedef Dart__suseconds_t = int;
typedef __suseconds64_t = ffi.Long;
typedef Dart__suseconds64_t = int;
typedef __daddr_t = ffi.Int;
typedef Dart__daddr_t = int;
typedef __key_t = ffi.Int;
typedef Dart__key_t = int;
typedef __clockid_t = ffi.Int;
typedef Dart__clockid_t = int;
typedef __timer_t = ffi.Pointer<ffi.Void>;
typedef __blksize_t = ffi.Long;
typedef Dart__blksize_t = int;
typedef __blkcnt_t = ffi.Long;
typedef Dart__blkcnt_t = int;
typedef __blkcnt64_t = ffi.Long;
typedef Dart__blkcnt64_t = int;
typedef __fsblkcnt_t = ffi.UnsignedLong;
typedef Dart__fsblkcnt_t = int;
typedef __fsblkcnt64_t = ffi.UnsignedLong;
typedef Dart__fsblkcnt64_t = int;
typedef __fsfilcnt_t = ffi.UnsignedLong;
typedef Dart__fsfilcnt_t = int;
typedef __fsfilcnt64_t = ffi.UnsignedLong;
typedef Dart__fsfilcnt64_t = int;
typedef __fsword_t = ffi.Long;
typedef Dart__fsword_t = int;
typedef __ssize_t = ffi.Long;
typedef Dart__ssize_t = int;
typedef __syscall_slong_t = ffi.Long;
typedef Dart__syscall_slong_t = int;
typedef __syscall_ulong_t = ffi.UnsignedLong;
typedef Dart__syscall_ulong_t = int;
typedef __loff_t = __off64_t;
typedef __caddr_t = ffi.Pointer<ffi.Char>;
typedef __intptr_t = ffi.Long;
typedef Dart__intptr_t = int;
typedef __socklen_t = ffi.UnsignedInt;
typedef Dart__socklen_t = int;
typedef __sig_atomic_t = ffi.Int;
typedef Dart__sig_atomic_t = int;
typedef u_char = __u_char;
typedef u_short = __u_short;
typedef u_int = __u_int;
typedef u_long = __u_long;
typedef quad_t = __quad_t;
typedef u_quad_t = __u_quad_t;
typedef fsid_t = __fsid_t;
typedef loff_t = __loff_t;
typedef ino_t = __ino_t;
typedef dev_t = __dev_t;
typedef gid_t = __gid_t;
typedef mode_t = __mode_t;
typedef nlink_t = __nlink_t;
typedef uid_t = __uid_t;
typedef off_t = __off_t;
typedef pid_t = __pid_t;
typedef id_t = __id_t;
typedef ssize_t = __ssize_t;
typedef daddr_t = __daddr_t;
typedef caddr_t = __caddr_t;
typedef key_t = __key_t;
typedef clock_t = __clock_t;
typedef clockid_t = __clockid_t;
typedef time_t = __time_t;
typedef timer_t = __timer_t;
typedef ulong = ffi.UnsignedLong;
typedef Dartulong = int;
typedef ushort = ffi.UnsignedShort;
typedef Dartushort = int;
typedef uint = ffi.UnsignedInt;
typedef Dartuint = int;
typedef u_int8_t = __uint8_t;
typedef u_int16_t = __uint16_t;
typedef u_int32_t = __uint32_t;
typedef u_int64_t = __uint64_t;
typedef register_t = ffi.Long;
typedef Dartregister_t = int;

final class __sigset_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedLong> __val;
}

typedef sigset_t = __sigset_t;
typedef suseconds_t = __suseconds_t;
typedef __fd_mask = ffi.Long;
typedef Dart__fd_mask = int;
typedef fd_mask = __fd_mask;
typedef blksize_t = __blksize_t;
typedef blkcnt_t = __blkcnt_t;
typedef fsblkcnt_t = __fsblkcnt_t;
typedef fsfilcnt_t = __fsfilcnt_t;

final class UnnamedStruct extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __low;

  @ffi.UnsignedInt()
  external int __high;
}

final class __atomic_wide_counter extends ffi.Union {
  @ffi.UnsignedLongLong()
  external int __value64;

  external UnnamedStruct __value32;
}

final class __pthread_internal_list extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_list> __prev;

  external ffi.Pointer<__pthread_internal_list> __next;
}

typedef __pthread_list_t = __pthread_internal_list;

final class __pthread_internal_slist extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_slist> __next;
}

typedef __pthread_slist_t = __pthread_internal_slist;

final class __pthread_mutex_s extends ffi.Struct {
  @ffi.Int()
  external int __lock;

  @ffi.UnsignedInt()
  external int __count;

  @ffi.Int()
  external int __owner;

  @ffi.UnsignedInt()
  external int __nusers;

  @ffi.Int()
  external int __kind;

  @ffi.Short()
  external int __spins;

  @ffi.Short()
  external int __elision;

  external __pthread_list_t __list;
}

final class __pthread_rwlock_arch_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __readers;

  @ffi.UnsignedInt()
  external int __writers;

  @ffi.UnsignedInt()
  external int __wrphase_futex;

  @ffi.UnsignedInt()
  external int __writers_futex;

  @ffi.UnsignedInt()
  external int __pad3;

  @ffi.UnsignedInt()
  external int __pad4;

  @ffi.Int()
  external int __cur_writer;

  @ffi.Int()
  external int __shared;

  @ffi.SignedChar()
  external int __rwelision;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedChar> __pad1;

  @ffi.UnsignedLong()
  external int __pad2;

  @ffi.UnsignedInt()
  external int __flags;
}

final class __pthread_cond_s extends ffi.Struct {
  external __atomic_wide_counter __wseq;

  external __atomic_wide_counter __g1_start;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_refs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_size;

  @ffi.UnsignedInt()
  external int __g1_orig_size;

  @ffi.UnsignedInt()
  external int __wrefs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_signals;
}

typedef __tss_t = ffi.UnsignedInt;
typedef Dart__tss_t = int;
typedef __thrd_t = ffi.UnsignedLong;
typedef Dart__thrd_t = int;
typedef pthread_t = ffi.UnsignedLong;
typedef Dartpthread_t = int;

final class pthread_mutexattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

final class pthread_condattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

typedef pthread_key_t = ffi.UnsignedInt;
typedef Dartpthread_key_t = int;
typedef pthread_once_t = ffi.Int;
typedef Dartpthread_once_t = int;

final class pthread_attr_t extends ffi.Union {
  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_mutex_t extends ffi.Union {
  external __pthread_mutex_s __data;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_cond_t extends ffi.Union {
  external __pthread_cond_s __data;

  @ffi.Array.multi([48])
  external ffi.Array<ffi.Char> __size;

  @ffi.LongLong()
  external int __align;
}

final class pthread_rwlock_t extends ffi.Union {
  external __pthread_rwlock_arch_t __data;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_rwlockattr_t extends ffi.Union {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_barrier_t extends ffi.Union {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_barrierattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

typedef int_least8_t = __int_least8_t;
typedef int_least16_t = __int_least16_t;
typedef int_least32_t = __int_least32_t;
typedef int_least64_t = __int_least64_t;
typedef uint_least8_t = __uint_least8_t;
typedef uint_least16_t = __uint_least16_t;
typedef uint_least32_t = __uint_least32_t;
typedef uint_least64_t = __uint_least64_t;
typedef int_fast8_t = ffi.SignedChar;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Long;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Long;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.Long;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.UnsignedChar;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.UnsignedLong;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.UnsignedLong;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.UnsignedLong;
typedef Dartuint_fast64_t = int;
typedef intmax_t = __intmax_t;
typedef uintmax_t = __uintmax_t;
typedef __gwchar_t = ffi.Int;
typedef Dart__gwchar_t = int;
typedef mdb_mode_t = mode_t;

/// Unsigned type used for mapsize, entry counts and page/transaction IDs.
///
/// It is normally size_t, hence the name. Defining MDB_VL32 makes it
/// uint64_t, but do not try this unless you know what you are doing.
typedef mdb_size_t = ffi.Size;
typedef Dartmdb_size_t = int;
typedef mdb_filehandle_t = ffi.Int;
typedef Dartmdb_filehandle_t = int;

final class MDB_env extends ffi.Opaque {}

final class MDB_txn extends ffi.Opaque {}

/// @brief A handle for an individual database in the DB environment.
typedef MDB_dbi = ffi.UnsignedInt;
typedef DartMDB_dbi = int;

final class MDB_cursor extends ffi.Opaque {}

/// @brief Generic structure used for passing keys and data in and out
/// of the database.
///
/// Values returned from the database are valid only until a subsequent
/// update operation, or the end of the transaction. Do not modify or
/// free them, they commonly point into the database itself.
///
/// Key sizes must be between 1 and #mdb_env_get_maxkeysize() inclusive.
/// The same applies to data sizes in databases with the #MDB_DUPSORT flag.
/// Other data items can in theory be from 0 to 0xffffffff bytes long.
final class MDB_val extends ffi.Struct {
  /// < size of the data item
  @ffi.Size()
  external int mv_size;

  /// < address of the data item
  external ffi.Pointer<ffi.Void> mv_data;
}

/// @brief A callback function used to compare two keys in a database
typedef MDB_cmp_func =
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<MDB_val> a, ffi.Pointer<MDB_val> b)
    >;

/// @brief A callback function used to relocate a position-dependent data item
/// in a fixed-address database.
///
/// The \b newptr gives the item's desired address in
/// the memory map, and \b oldptr gives its previous address. The item's actual
/// data resides at the address in \b item.  This callback is expected to walk
/// through the fields of the record in \b item and modify any
/// values based at the \b oldptr address to be relative to the \b newptr address.
/// @param[in,out] item The item that is to be relocated.
/// @param[in] oldptr The previous address.
/// @param[in] newptr The new address to relocate to.
/// @param[in] relctx An application-provided context, set by #mdb_set_relctx().
/// @todo This feature is currently unimplemented.
typedef MDB_rel_func =
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<MDB_val> item,
        ffi.Pointer<ffi.Void> oldptr,
        ffi.Pointer<ffi.Void> newptr,
        ffi.Pointer<ffi.Void> relctx,
      )
    >;

/// @brief Cursor Get operations.
///
/// This is the set of all operations for retrieving data
/// using a cursor.
enum MDB_cursor_op {
  /// < Position at first key/data item
  MDB_FIRST(0),

  /// < Position at first data item of current key.
  /// Only for #MDB_DUPSORT
  MDB_FIRST_DUP(1),

  /// < Position at key/data pair. Only for #MDB_DUPSORT
  MDB_GET_BOTH(2),

  /// < position at key, nearest data. Only for #MDB_DUPSORT
  MDB_GET_BOTH_RANGE(3),

  /// < Return key/data at current cursor position
  MDB_GET_CURRENT(4),

  /// < Return up to a page of duplicate data items
  /// from current cursor position. Move cursor to prepare
  /// for #MDB_NEXT_MULTIPLE. Only for #MDB_DUPFIXED
  MDB_GET_MULTIPLE(5),

  /// < Position at last key/data item
  MDB_LAST(6),

  /// < Position at last data item of current key.
  /// Only for #MDB_DUPSORT
  MDB_LAST_DUP(7),

  /// < Position at next data item
  MDB_NEXT(8),

  /// < Position at next data item of current key.
  /// Only for #MDB_DUPSORT
  MDB_NEXT_DUP(9),

  /// < Return up to a page of duplicate data items
  /// from next cursor position. Move cursor to prepare
  /// for #MDB_NEXT_MULTIPLE. Only for #MDB_DUPFIXED
  MDB_NEXT_MULTIPLE(10),

  /// < Position at first data item of next key
  MDB_NEXT_NODUP(11),

  /// < Position at previous data item
  MDB_PREV(12),

  /// < Position at previous data item of current key.
  /// Only for #MDB_DUPSORT
  MDB_PREV_DUP(13),

  /// < Position at last data item of previous key
  MDB_PREV_NODUP(14),

  /// < Position at specified key
  MDB_SET(15),

  /// < Position at specified key, return key + data
  MDB_SET_KEY(16),

  /// < Position at first key greater than or equal to specified key.
  MDB_SET_RANGE(17),

  /// < Position at previous page and return up to
  /// a page of duplicate data items. Only for #MDB_DUPFIXED
  MDB_PREV_MULTIPLE(18);

  final int value;
  const MDB_cursor_op(this.value);

  static MDB_cursor_op fromValue(int value) => switch (value) {
    0 => MDB_FIRST,
    1 => MDB_FIRST_DUP,
    2 => MDB_GET_BOTH,
    3 => MDB_GET_BOTH_RANGE,
    4 => MDB_GET_CURRENT,
    5 => MDB_GET_MULTIPLE,
    6 => MDB_LAST,
    7 => MDB_LAST_DUP,
    8 => MDB_NEXT,
    9 => MDB_NEXT_DUP,
    10 => MDB_NEXT_MULTIPLE,
    11 => MDB_NEXT_NODUP,
    12 => MDB_PREV,
    13 => MDB_PREV_DUP,
    14 => MDB_PREV_NODUP,
    15 => MDB_SET,
    16 => MDB_SET_KEY,
    17 => MDB_SET_RANGE,
    18 => MDB_PREV_MULTIPLE,
    _ => throw ArgumentError('Unknown value for MDB_cursor_op: $value'),
  };
}

/// @brief Statistics for a database in the environment
final class MDB_stat extends ffi.Struct {
  /// < Size of a database page.
  /// This is currently the same for all databases.
  @ffi.UnsignedInt()
  external int ms_psize;

  /// < Depth (height) of the B-tree
  @ffi.UnsignedInt()
  external int ms_depth;

  /// < Number of internal (non-leaf) pages
  @mdb_size_t()
  external int ms_branch_pages;

  /// < Number of leaf pages
  @mdb_size_t()
  external int ms_leaf_pages;

  /// < Number of overflow pages
  @mdb_size_t()
  external int ms_overflow_pages;

  /// < Number of data items
  @mdb_size_t()
  external int ms_entries;
}

/// @brief Information about the environment
final class MDB_envinfo extends ffi.Struct {
  /// < Address of map, if fixed
  external ffi.Pointer<ffi.Void> me_mapaddr;

  /// < Size of the data memory map
  @mdb_size_t()
  external int me_mapsize;

  /// < ID of the last used page
  @mdb_size_t()
  external int me_last_pgno;

  /// < ID of the last committed transaction
  @mdb_size_t()
  external int me_last_txnid;

  /// < max reader slots in the environment
  @ffi.UnsignedInt()
  external int me_maxreaders;

  /// < max reader slots used in the environment
  @ffi.UnsignedInt()
  external int me_numreaders;
}

/// @brief A callback function for most LMDB assert() failures,
/// called before printing the message and aborting.
///
/// @param[in] env An environment handle returned by #mdb_env_create().
/// @param[in] msg The assertion message, not including newline.
typedef MDB_assert_func =
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<MDB_env> env, ffi.Pointer<ffi.Char> msg)
    >;

/// @brief A callback function used to print a message from the library.
///
/// @param[in] msg The string to be printed.
/// @param[in] ctx An arbitrary context pointer for the callback.
/// @return < 0 on failure, >= 0 on success.
typedef MDB_msg_func =
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<ffi.Char> msg, ffi.Pointer<ffi.Void> ctx)
    >;

const int _SYS_TYPES_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_60559_BFP__ = 201404;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_IEC_60559_COMPLEX__ = 201404;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 35;

const int _SYS_CDEFS_H = 1;

const int __THROW = 1;

const int __THROWNL = 1;

const int __glibc_c99_flexarr_available = 1;

const int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int __clock_t_defined = 1;

const int __clockid_t_defined = 1;

const int __time_t_defined = 1;

const int __timer_t_defined = 1;

const int _BITS_STDINT_INTN_H = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int __timeval_defined = 1;

const int _STRUCT_TIMESPEC = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int __have_pthread_attr_t = 1;

const int _INTTYPES_H = 1;

const int _STDINT_H = 1;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_UINTN_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int ____gwchar_t_defined = 1;

const String __PRI64_PREFIX = 'l';

const String __PRIPTR_PREFIX = 'l';

const String PRId8 = 'd';

const String PRId16 = 'd';

const String PRId32 = 'd';

const String PRId64 = 'ld';

const String PRIdLEAST8 = 'd';

const String PRIdLEAST16 = 'd';

const String PRIdLEAST32 = 'd';

const String PRIdLEAST64 = 'ld';

const String PRIdFAST8 = 'd';

const String PRIdFAST16 = 'ld';

const String PRIdFAST32 = 'ld';

const String PRIdFAST64 = 'ld';

const String PRIi8 = 'i';

const String PRIi16 = 'i';

const String PRIi32 = 'i';

const String PRIi64 = 'li';

const String PRIiLEAST8 = 'i';

const String PRIiLEAST16 = 'i';

const String PRIiLEAST32 = 'i';

const String PRIiLEAST64 = 'li';

const String PRIiFAST8 = 'i';

const String PRIiFAST16 = 'li';

const String PRIiFAST32 = 'li';

const String PRIiFAST64 = 'li';

const String PRIo8 = 'o';

const String PRIo16 = 'o';

const String PRIo32 = 'o';

const String PRIo64 = 'lo';

const String PRIoLEAST8 = 'o';

const String PRIoLEAST16 = 'o';

const String PRIoLEAST32 = 'o';

const String PRIoLEAST64 = 'lo';

const String PRIoFAST8 = 'o';

const String PRIoFAST16 = 'lo';

const String PRIoFAST32 = 'lo';

const String PRIoFAST64 = 'lo';

const String PRIu8 = 'u';

const String PRIu16 = 'u';

const String PRIu32 = 'u';

const String PRIu64 = 'lu';

const String PRIuLEAST8 = 'u';

const String PRIuLEAST16 = 'u';

const String PRIuLEAST32 = 'u';

const String PRIuLEAST64 = 'lu';

const String PRIuFAST8 = 'u';

const String PRIuFAST16 = 'lu';

const String PRIuFAST32 = 'lu';

const String PRIuFAST64 = 'lu';

const String PRIx8 = 'x';

const String PRIx16 = 'x';

const String PRIx32 = 'x';

const String PRIx64 = 'lx';

const String PRIxLEAST8 = 'x';

const String PRIxLEAST16 = 'x';

const String PRIxLEAST32 = 'x';

const String PRIxLEAST64 = 'lx';

const String PRIxFAST8 = 'x';

const String PRIxFAST16 = 'lx';

const String PRIxFAST32 = 'lx';

const String PRIxFAST64 = 'lx';

const String PRIX8 = 'X';

const String PRIX16 = 'X';

const String PRIX32 = 'X';

const String PRIX64 = 'lX';

const String PRIXLEAST8 = 'X';

const String PRIXLEAST16 = 'X';

const String PRIXLEAST32 = 'X';

const String PRIXLEAST64 = 'lX';

const String PRIXFAST8 = 'X';

const String PRIXFAST16 = 'lX';

const String PRIXFAST32 = 'lX';

const String PRIXFAST64 = 'lX';

const String PRIdMAX = 'ld';

const String PRIiMAX = 'li';

const String PRIoMAX = 'lo';

const String PRIuMAX = 'lu';

const String PRIxMAX = 'lx';

const String PRIXMAX = 'lX';

const String PRIdPTR = 'ld';

const String PRIiPTR = 'li';

const String PRIoPTR = 'lo';

const String PRIuPTR = 'lu';

const String PRIxPTR = 'lx';

const String PRIXPTR = 'lX';

const String SCNd8 = 'hhd';

const String SCNd16 = 'hd';

const String SCNd32 = 'd';

const String SCNd64 = 'ld';

const String SCNdLEAST8 = 'hhd';

const String SCNdLEAST16 = 'hd';

const String SCNdLEAST32 = 'd';

const String SCNdLEAST64 = 'ld';

const String SCNdFAST8 = 'hhd';

const String SCNdFAST16 = 'ld';

const String SCNdFAST32 = 'ld';

const String SCNdFAST64 = 'ld';

const String SCNi8 = 'hhi';

const String SCNi16 = 'hi';

const String SCNi32 = 'i';

const String SCNi64 = 'li';

const String SCNiLEAST8 = 'hhi';

const String SCNiLEAST16 = 'hi';

const String SCNiLEAST32 = 'i';

const String SCNiLEAST64 = 'li';

const String SCNiFAST8 = 'hhi';

const String SCNiFAST16 = 'li';

const String SCNiFAST32 = 'li';

const String SCNiFAST64 = 'li';

const String SCNu8 = 'hhu';

const String SCNu16 = 'hu';

const String SCNu32 = 'u';

const String SCNu64 = 'lu';

const String SCNuLEAST8 = 'hhu';

const String SCNuLEAST16 = 'hu';

const String SCNuLEAST32 = 'u';

const String SCNuLEAST64 = 'lu';

const String SCNuFAST8 = 'hhu';

const String SCNuFAST16 = 'lu';

const String SCNuFAST32 = 'lu';

const String SCNuFAST64 = 'lu';

const String SCNo8 = 'hho';

const String SCNo16 = 'ho';

const String SCNo32 = 'o';

const String SCNo64 = 'lo';

const String SCNoLEAST8 = 'hho';

const String SCNoLEAST16 = 'ho';

const String SCNoLEAST32 = 'o';

const String SCNoLEAST64 = 'lo';

const String SCNoFAST8 = 'hho';

const String SCNoFAST16 = 'lo';

const String SCNoFAST32 = 'lo';

const String SCNoFAST64 = 'lo';

const String SCNx8 = 'hhx';

const String SCNx16 = 'hx';

const String SCNx32 = 'x';

const String SCNx64 = 'lx';

const String SCNxLEAST8 = 'hhx';

const String SCNxLEAST16 = 'hx';

const String SCNxLEAST32 = 'x';

const String SCNxLEAST64 = 'lx';

const String SCNxFAST8 = 'hhx';

const String SCNxFAST16 = 'lx';

const String SCNxFAST32 = 'lx';

const String SCNxFAST64 = 'lx';

const String SCNdMAX = 'ld';

const String SCNiMAX = 'li';

const String SCNoMAX = 'lo';

const String SCNuMAX = 'lu';

const String SCNxMAX = 'lx';

const String SCNdPTR = 'ld';

const String SCNiPTR = 'li';

const String SCNoPTR = 'lo';

const String SCNuPTR = 'lu';

const String SCNxPTR = 'lx';

const int _LIBC_LIMITS_H_ = 1;

const int MB_LEN_MAX = 16;

const int LLONG_MIN = -9223372036854775808;

const int LLONG_MAX = 9223372036854775807;

const int ULLONG_MAX = -1;

const int _BITS_POSIX1_LIM_H = 1;

const int _POSIX_AIO_LISTIO_MAX = 2;

const int _POSIX_AIO_MAX = 1;

const int _POSIX_ARG_MAX = 4096;

const int _POSIX_CHILD_MAX = 25;

const int _POSIX_DELAYTIMER_MAX = 32;

const int _POSIX_HOST_NAME_MAX = 255;

const int _POSIX_LINK_MAX = 8;

const int _POSIX_LOGIN_NAME_MAX = 9;

const int _POSIX_MAX_CANON = 255;

const int _POSIX_MAX_INPUT = 255;

const int _POSIX_MQ_OPEN_MAX = 8;

const int _POSIX_MQ_PRIO_MAX = 32;

const int _POSIX_NAME_MAX = 14;

const int _POSIX_NGROUPS_MAX = 8;

const int _POSIX_OPEN_MAX = 20;

const int _POSIX_PATH_MAX = 256;

const int _POSIX_PIPE_BUF = 512;

const int _POSIX_RE_DUP_MAX = 255;

const int _POSIX_RTSIG_MAX = 8;

const int _POSIX_SEM_NSEMS_MAX = 256;

const int _POSIX_SEM_VALUE_MAX = 32767;

const int _POSIX_SIGQUEUE_MAX = 32;

const int _POSIX_SSIZE_MAX = 32767;

const int _POSIX_STREAM_MAX = 8;

const int _POSIX_SYMLINK_MAX = 255;

const int _POSIX_SYMLOOP_MAX = 8;

const int _POSIX_TIMER_MAX = 32;

const int _POSIX_TTY_NAME_MAX = 9;

const int _POSIX_TZNAME_MAX = 6;

const int _POSIX_CLOCKRES_MIN = 20000000;

const int NGROUPS_MAX = 65536;

const int MAX_CANON = 255;

const int MAX_INPUT = 255;

const int NAME_MAX = 255;

const int PATH_MAX = 4096;

const int PIPE_BUF = 4096;

const int XATTR_NAME_MAX = 255;

const int XATTR_SIZE_MAX = 65536;

const int XATTR_LIST_MAX = 65536;

const int RTSIG_MAX = 32;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int PTHREAD_KEYS_MAX = 1024;

const int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;

const int PTHREAD_DESTRUCTOR_ITERATIONS = 4;

const int _POSIX_THREAD_THREADS_MAX = 64;

const int AIO_PRIO_DELTA_MAX = 20;

const int DELAYTIMER_MAX = 2147483647;

const int TTY_NAME_MAX = 32;

const int LOGIN_NAME_MAX = 256;

const int HOST_NAME_MAX = 64;

const int MQ_PRIO_MAX = 32768;

const int SEM_VALUE_MAX = 2147483647;

const int SSIZE_MAX = 9223372036854775807;

const int _BITS_POSIX2_LIM_H = 1;

const int _POSIX2_BC_BASE_MAX = 99;

const int _POSIX2_BC_DIM_MAX = 2048;

const int _POSIX2_BC_SCALE_MAX = 99;

const int _POSIX2_BC_STRING_MAX = 1000;

const int _POSIX2_COLL_WEIGHTS_MAX = 2;

const int _POSIX2_EXPR_NEST_MAX = 32;

const int _POSIX2_LINE_MAX = 2048;

const int _POSIX2_RE_DUP_MAX = 255;

const int _POSIX2_CHARCLASS_NAME_MAX = 14;

const int BC_BASE_MAX = 99;

const int BC_DIM_MAX = 2048;

const int BC_SCALE_MAX = 99;

const int BC_STRING_MAX = 1000;

const int COLL_WEIGHTS_MAX = 255;

const int EXPR_NEST_MAX = 32;

const int LINE_MAX = 2048;

const int CHARCLASS_NAME_MAX = 2048;

const int RE_DUP_MAX = 32767;

const int SCHAR_MAX = 127;

const int SHRT_MAX = 32767;

const int INT_MAX = 2147483647;

const int LONG_MAX = 9223372036854775807;

const int SCHAR_MIN = -128;

const int SHRT_MIN = -32768;

const int INT_MIN = -2147483648;

const int LONG_MIN = -9223372036854775808;

const int UCHAR_MAX = 255;

const int USHRT_MAX = 65535;

const int UINT_MAX = 4294967295;

const int ULONG_MAX = -1;

const int CHAR_BIT = 8;

const int CHAR_MIN = -128;

const int CHAR_MAX = 127;

const String MDB_FMT_Z = 'z';

const int MDB_SIZE_MAX = -1;

const int MDB_VERSION_MAJOR = 0;

const int MDB_VERSION_MINOR = 9;

const int MDB_VERSION_PATCH = 70;

const int MDB_VERSION_FULL = 589894;

const String MDB_VERSION_DATE = 'December 19, 2015';

const String MDB_VERSION_STRING = 'LMDB 0.9.70: (December 19, 2015)';

const int MDB_FIXEDMAP = 1;

const int MDB_NOSUBDIR = 16384;

const int MDB_NOSYNC = 65536;

const int MDB_RDONLY = 131072;

const int MDB_NOMETASYNC = 262144;

const int MDB_WRITEMAP = 524288;

const int MDB_MAPASYNC = 1048576;

const int MDB_NOTLS = 2097152;

const int MDB_NOLOCK = 4194304;

const int MDB_NORDAHEAD = 8388608;

const int MDB_NOMEMINIT = 16777216;

const int MDB_PREVSNAPSHOT = 33554432;

const int MDB_REVERSEKEY = 2;

const int MDB_DUPSORT = 4;

const int MDB_INTEGERKEY = 8;

const int MDB_DUPFIXED = 16;

const int MDB_INTEGERDUP = 32;

const int MDB_REVERSEDUP = 64;

const int MDB_CREATE = 262144;

const int MDB_NOOVERWRITE = 16;

const int MDB_NODUPDATA = 32;

const int MDB_CURRENT = 64;

const int MDB_RESERVE = 65536;

const int MDB_APPEND = 131072;

const int MDB_APPENDDUP = 262144;

const int MDB_MULTIPLE = 524288;

const int MDB_CP_COMPACT = 1;

const int MDB_SUCCESS = 0;

const int MDB_KEYEXIST = -30799;

const int MDB_NOTFOUND = -30798;

const int MDB_PAGE_NOTFOUND = -30797;

const int MDB_CORRUPTED = -30796;

const int MDB_PANIC = -30795;

const int MDB_VERSION_MISMATCH = -30794;

const int MDB_INVALID = -30793;

const int MDB_MAP_FULL = -30792;

const int MDB_DBS_FULL = -30791;

const int MDB_READERS_FULL = -30790;

const int MDB_TLS_FULL = -30789;

const int MDB_TXN_FULL = -30788;

const int MDB_CURSOR_FULL = -30787;

const int MDB_PAGE_FULL = -30786;

const int MDB_MAP_RESIZED = -30785;

const int MDB_INCOMPATIBLE = -30784;

const int MDB_BAD_RSLOT = -30783;

const int MDB_BAD_TXN = -30782;

const int MDB_BAD_VALSIZE = -30781;

const int MDB_BAD_DBI = -30780;

const int MDB_PROBLEM = -30779;

const int MDB_LAST_ERRCODE = -30779;
